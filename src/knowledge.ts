import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { checkClaude } from "./deps.js";
import { completedDir, decisionsPath, knowledgePath, mistakesPath, SESSION_DIR } from "./paths.js";
import { searchSessions } from "./qmd.js";
import { listCompletedSessions } from "./session.js";

// =============================================================================
// Claude CLI Check
// =============================================================================

async function requireClaude(action: string): Promise<boolean> {
  const status = await checkClaude();
  if (!status.available) {
    console.error(`claude CLI not found — ${action} requires it.`);
    console.error("Install: https://claude.ai/download");
    return false;
  }
  return true;
}

// =============================================================================
// Knowledge Base
// =============================================================================

const KNOWLEDGE_PROMPT = `You are consolidating AI coding session summaries into a project knowledge base.
Read the existing knowledge base (if any) and the new session summaries.
Merge new information into the knowledge base, updating existing sections and adding new ones as needed.
Keep the following fixed sections:

# Project Knowledge Base

## Architecture
Key architectural patterns, file structure, tech stack.

## Conventions
Coding conventions, naming patterns, testing approaches.

## Key Decisions
Important technical decisions with date and reasoning.

## Gotchas
Known issues, API quirks, things to watch out for.

## Patterns That Work
Proven approaches for common tasks.

## Open Threads
Unresolved items, things still being explored.

Keep it concise. Remove outdated info. Add date references where helpful.`;

/** Rebuild the knowledge base from all completed sessions */
export async function buildKnowledge(repoRoot: string): Promise<void> {
  if (!(await requireClaude("knowledge build"))) return;

  const sessions = listCompletedSessions(repoRoot);
  if (sessions.length === 0) {
    console.log("No completed sessions to build knowledge from.");
    return;
  }

  // Gather all session summaries
  const summaries: string[] = [];
  for (const id of sessions) {
    const path = join(completedDir(repoRoot), `${id}.md`);
    if (!existsSync(path)) continue;
    const content = readFileSync(path, "utf8");
    const summaryMatch = content.match(/## Summary\n([\s\S]*?)$/);
    if (summaryMatch) {
      summaries.push(`### Session ${id}\n${summaryMatch[1]!.trim()}`);
    }
  }

  if (summaries.length === 0) {
    console.log("No session summaries found. Run sessions first or wait for AI summarization.");
    return;
  }

  const existing = existsSync(knowledgePath(repoRoot)) ? readFileSync(knowledgePath(repoRoot), "utf8") : "";
  const input = `${existing ? `EXISTING KNOWLEDGE BASE:\n${existing}\n\n` : ""}NEW SESSION SUMMARIES:\n${summaries.join("\n\n")}`;

  try {
    const proc = Bun.spawn(["claude", "-p", KNOWLEDGE_PROMPT], {
      stdin: new TextEncoder().encode(input),
      stdout: "pipe",
      stderr: "pipe",
      env: { ...process.env, GHOST_INTERNAL: "1" },
    });
    const stdout = await new Response(proc.stdout).text();
    const exitCode = await proc.exited;
    if (exitCode !== 0) {
      console.error("Knowledge build failed — claude CLI returned non-zero.");
      return;
    }
    mkdirSync(join(repoRoot, SESSION_DIR), { recursive: true });
    const header = `_Auto-generated by Ghost. Last updated: ${new Date().toISOString().slice(0, 10)}_\n\n`;
    writeFileSync(knowledgePath(repoRoot), `${header + stdout.trim()}\n`);
    console.log("Knowledge base rebuilt.");
  } catch (err) {
    console.error(`Knowledge build failed: ${err instanceof Error ? err.message : String(err)}`);
  }
}

/** Append/symlink knowledge base to CLAUDE.md */
export async function injectKnowledge(repoRoot: string): Promise<void> {
  const kPath = knowledgePath(repoRoot);
  if (!existsSync(kPath)) {
    console.log("No knowledge base found. Run `ghost knowledge build` first.");
    return;
  }

  const claudeMdPath = join(repoRoot, "CLAUDE.md");
  const knowledge = readFileSync(kPath, "utf8");
  const marker = "<!-- ghost:knowledge -->";
  const block = `\n${marker}\n${knowledge}\n${marker}\n`;

  if (existsSync(claudeMdPath)) {
    const existing = readFileSync(claudeMdPath, "utf8");
    if (existing.includes(marker)) {
      const updated = existing.replace(new RegExp(`\\n?${marker}[\\s\\S]*?${marker}\\n?`), block);
      writeFileSync(claudeMdPath, updated);
    } else {
      writeFileSync(claudeMdPath, `${existing.trimEnd()}\n${block}`);
    }
  } else {
    writeFileSync(claudeMdPath, block);
  }
  console.log("Knowledge injected into CLAUDE.md.");
}

/** Print the current knowledge base */
export function showKnowledge(repoRoot: string): void {
  const kPath = knowledgePath(repoRoot);
  if (!existsSync(kPath)) {
    console.log("No knowledge base found. Run `ghost knowledge build` first.");
    return;
  }
  console.log(readFileSync(kPath, "utf8"));
}

/** Show what changed since last build (simplified diff) */
export function diffKnowledge(repoRoot: string): void {
  const kPath = knowledgePath(repoRoot);
  if (!existsSync(kPath)) {
    console.log("No knowledge base found.");
    return;
  }
  console.log("Current knowledge base (use `ghost knowledge build` to update):\n");
  console.log(readFileSync(kPath, "utf8"));
}

// =============================================================================
// Scope Briefing
// =============================================================================

const BRIEF_PROMPT = `Generate a scope briefing for the following work description, using the provided context from past sessions, decisions, known issues, and file modification frequency. Include:

## Brief: {title}

### Relevant Past Work
Sessions and what was done.

### Key Files
Files most likely to be involved, ranked by modification frequency.

### Relevant Decisions
Applicable past decisions.

### Watch Out For
Known gotchas and pitfalls from the mistake ledger.

### Suggested Starting Point
Where to begin.

Be concise and actionable.`;

/** Generate a scoped context brief */
export async function generateBrief(repoRoot: string, description: string): Promise<void> {
  if (!(await requireClaude("brief generation"))) return;

  const parts: string[] = [`WORK DESCRIPTION: ${description}\n`];

  // Search for relevant sessions via QMD
  const searchResults = await searchSessions(description);
  if (searchResults && !searchResults.startsWith("QMD is not installed")) {
    parts.push(`RELEVANT SESSIONS:\n${searchResults}\n`);
  }

  // Include decisions
  if (existsSync(decisionsPath(repoRoot))) {
    const decisions = readFileSync(decisionsPath(repoRoot), "utf8");
    if (decisions.trim()) {
      parts.push(`DECISION LOG:\n${decisions}\n`);
    }
  }

  // Include mistakes
  if (existsSync(mistakesPath(repoRoot))) {
    const mistakes = readFileSync(mistakesPath(repoRoot), "utf8");
    if (mistakes.trim()) {
      parts.push(`KNOWN ISSUES:\n${mistakes}\n`);
    }
  }

  // Include file heatmap data
  const heatmap = buildHeatmapData(repoRoot);
  if (heatmap.length > 0) {
    const top = heatmap.slice(0, 20);
    const heatmapStr = top.map(([file, count]) => `  ${count} changes | ${file}`).join("\n");
    parts.push(`FILE MODIFICATION FREQUENCY (top 20):\n${heatmapStr}\n`);
  }

  const input = parts.join("\n");

  try {
    const proc = Bun.spawn(["claude", "-p", BRIEF_PROMPT], {
      stdin: new TextEncoder().encode(input),
      stdout: "pipe",
      stderr: "pipe",
      env: { ...process.env, GHOST_INTERNAL: "1" },
    });
    const stdout = await new Response(proc.stdout).text();
    const exitCode = await proc.exited;
    if (exitCode !== 0) {
      console.error("Brief generation failed.");
      return;
    }
    console.log(stdout.trim());
  } catch (err) {
    console.error(`Brief generation failed: ${err instanceof Error ? err.message : String(err)}`);
  }
}

// =============================================================================
// Heatmap Data (shared with search.ts)
// =============================================================================

/** Build file modification frequency data from all completed sessions */
export function buildHeatmapData(repoRoot: string, sessionIds?: string[]): [string, number][] {
  const ids = sessionIds || listCompletedSessions(repoRoot);
  const counts: Record<string, number> = {};

  for (const id of ids) {
    const path = join(completedDir(repoRoot), `${id}.md`);
    if (!existsSync(path)) continue;
    const content = readFileSync(path, "utf8");
    const matches = content.matchAll(/^- Modified: (.+)$/gm);
    for (const match of matches) {
      const file = match[1]!;
      counts[file] = (counts[file] || 0) + 1;
    }
  }

  return Object.entries(counts).sort(([, a], [, b]) => b - a);
}

// =============================================================================
// Genesis — Initial Knowledge Base from Codebase
// =============================================================================

const GENESIS_PROMPT = `Analyze this codebase and generate an initial project knowledge base. This is the first time the project is being documented, so there are no prior sessions to draw from.

Return markdown with these sections:

# Project Knowledge Base

## Architecture
Key architectural patterns, file structure, tech stack. What frameworks, libraries, and languages are used? How is the code organized?

## Conventions
Coding conventions you observe: naming patterns, module structure, testing approaches, import style.

## Key Files
The most important files and what they do. Focus on entry points, config, and core business logic.

## Gotchas
Any potential issues you notice: missing error handling, hardcoded values, unusual patterns, things a developer should watch out for.

## Patterns That Work
Common patterns used throughout the codebase that should be followed for consistency.

## Open Threads
Areas that look incomplete, TODOs in the code, or things that might need attention.

Keep it concise and factual. Only document what you can observe in the code.`;

/** Build an initial knowledge base by analyzing the codebase (no sessions needed) */
export async function genesis(repoRoot: string): Promise<boolean> {
  if (!(await requireClaude("genesis"))) return false;

  console.log("Building initial knowledge base from codebase...");

  // Gather a snapshot of the project for analysis
  const parts: string[] = [];

  // List files in the project (respecting .gitignore via git ls-files)
  try {
    const { $ } = await import("bun");
    const result = await $`git -C ${repoRoot} ls-files`.quiet();
    const files = result.text().trim();
    if (files) {
      parts.push(`PROJECT FILES:\n${files}\n`);
    }
  } catch {
    // Fall back to nothing
  }

  // Read key files: package.json, README, config files, entry points
  const keyFiles = ["package.json", "Cargo.toml", "go.mod", "pyproject.toml", "Gemfile", "tsconfig.json", "CLAUDE.md"];
  for (const name of keyFiles) {
    const filePath = join(repoRoot, name);
    if (existsSync(filePath)) {
      const content = readFileSync(filePath, "utf8");
      parts.push(`FILE: ${name}\n\`\`\`\n${content.slice(0, 3000)}\n\`\`\`\n`);
    }
  }

  // Read src/ directory structure if it exists
  try {
    const { $ } = await import("bun");
    const result = await $`git -C ${repoRoot} ls-files -- 'src/'`.quiet();
    const srcFiles = result.text().trim();
    if (srcFiles) {
      // Read first few source files to understand patterns
      const files = srcFiles.split("\n").slice(0, 10);
      for (const f of files) {
        const filePath = join(repoRoot, f);
        if (existsSync(filePath)) {
          const content = readFileSync(filePath, "utf8");
          parts.push(`FILE: ${f}\n\`\`\`\n${content.slice(0, 2000)}\n\`\`\`\n`);
        }
      }
    }
  } catch {
    // Not every project has src/
  }

  if (parts.length === 0) {
    console.log("No files found to analyze.");
    return false;
  }

  const input = parts.join("\n");

  try {
    const proc = Bun.spawn(["claude", "-p", GENESIS_PROMPT], {
      stdin: new TextEncoder().encode(input),
      stdout: "pipe",
      stderr: "pipe",
      env: { ...process.env, GHOST_INTERNAL: "1" },
    });
    const stdout = await new Response(proc.stdout).text();
    const exitCode = await proc.exited;
    if (exitCode !== 0) {
      console.error("Genesis failed — claude CLI returned non-zero.");
      return false;
    }
    mkdirSync(join(repoRoot, SESSION_DIR), { recursive: true });
    const header = `_Auto-generated by Ghost (genesis). Last updated: ${new Date().toISOString().slice(0, 10)}_\n\n`;
    writeFileSync(knowledgePath(repoRoot), `${header + stdout.trim()}\n`);
    console.log("Initial knowledge base created.");
    return true;
  } catch (err) {
    console.error(`Genesis failed: ${err instanceof Error ? err.message : String(err)}`);
    return false;
  }
}

/** Check if knowledge base should be rebuilt (every N sessions) */
export function shouldRebuildKnowledge(repoRoot: string, threshold: number = 5): boolean {
  const sessions = listCompletedSessions(repoRoot);
  const kPath = knowledgePath(repoRoot);

  if (!existsSync(kPath)) return sessions.length >= threshold;

  // Check how many sessions since last build
  const knowledgeModified = Bun.file(kPath).lastModified;
  const newSessions = sessions.filter((id) => {
    const path = join(completedDir(repoRoot), `${id}.md`);
    if (!existsSync(path)) return false;
    return Bun.file(path).lastModified > knowledgeModified;
  });

  return newSessions.length >= threshold;
}
